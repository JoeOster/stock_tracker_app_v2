// public/event-handlers/_dashboard.js
// Version Updated (Hook up Manage Position Modal)
/**
 * @file Initializes event handlers for the Dashboard page.
 * @module event-handlers/_dashboard
 */

import { state } from '../state.js';
import { renderDashboardPage } from '../ui/renderers/_dashboard.js';
import { showToast, showConfirmationModal, sortTableByColumn } from '../ui/helpers.js';
// UPDATED: Import handleResponse for potential future batch fetch
import { fetchSalesForLot, updateAllPrices, handleResponse } from '../api.js';
import { getCurrentESTDateString } from '../ui/datetime.js';
import { formatAccounting, formatQuantity } from '../ui/formatters.js';
// Import switchView if needed for navigation actions (like the Manage Lots redirect)
// import { switchView } from './_navigation.js';

/**
 * Helper function to populate the Edit/Limits modal with data from a specific lot.
 * @param {object | undefined} lotData - The data object for the selected open lot.
 * @param {boolean} [limitsOnly=false] - If true, only show the limit fields.
 */
function populateEditModal(lotData, limitsOnly = false) {
    // ... (populateEditModal function remains the same - code omitted for brevity) ...

    const editModal = document.getElementById('edit-modal');
    if (!lotData || !editModal) {
        showToast('Could not find lot data or modal element.', 'error');
        return;
    }

    // --- Get all modal elements ---
    const editIdInput = /** @type {HTMLInputElement} */(document.getElementById('edit-id'));
    const editAccountHolderSelect = /** @type {HTMLSelectElement} */(document.getElementById('edit-account-holder'));
    const editDateInput = /** @type {HTMLInputElement} */(document.getElementById('edit-date'));
    const editTickerInput = /** @type {HTMLInputElement} */(document.getElementById('edit-ticker'));
    const editExchangeSelect = /** @type {HTMLSelectElement} */(document.getElementById('edit-exchange'));
    const editTypeSelect = /** @type {HTMLSelectElement} */(document.getElementById('edit-type'));
    const editQuantityInput = /** @type {HTMLInputElement} */(document.getElementById('edit-quantity'));
    const editPriceInput = /** @type {HTMLInputElement} */(document.getElementById('edit-price'));
    const editLimitPriceUpInput = /** @type {HTMLInputElement} */(document.getElementById('edit-limit-price-up'));
    const editLimitUpExpirationInput = /** @type {HTMLInputElement} */(document.getElementById('edit-limit-up-expiration'));
    const editLimitPriceDownInput = /** @type {HTMLInputElement} */(document.getElementById('edit-limit-price-down'));
    const editLimitDownExpirationInput = /** @type {HTMLInputElement} */(document.getElementById('edit-limit-down-expiration'));
    const coreFields = /** @type {HTMLElement} */ (document.getElementById('edit-core-fields'));
    const limitFields = /** @type {HTMLElement} */ (document.getElementById('edit-limit-fields'));
    const modalTitle = document.getElementById('edit-modal-title');

    // --- Check if all elements exist ---
    if (!editIdInput || !editAccountHolderSelect || !editDateInput || !editTickerInput || !editExchangeSelect || !editTypeSelect || !editQuantityInput || !editPriceInput || !editLimitPriceUpInput || !editLimitUpExpirationInput || !editLimitPriceDownInput || !editLimitDownExpirationInput || !coreFields || !limitFields || !modalTitle) {
         console.error("[Dashboard Event] One or more elements missing inside edit modal.");
         showToast("UI Error: Cannot display edit/limit details.", "error");
         return;
    }

    // --- Populate fields ---
    editIdInput.value = String(lotData.id);
    editAccountHolderSelect.value = String(lotData.account_holder_id);
    editDateInput.value = lotData.purchase_date; // Use purchase_date for BUY lots
    editTickerInput.value = lotData.ticker;
    editExchangeSelect.value = lotData.exchange;
    editTypeSelect.value = 'BUY'; // This modal is only for BUY transactions from dashboard
    // Use original_quantity if available (it should be on BUYs), otherwise fallback just in case
    editQuantityInput.value = String(lotData.original_quantity ?? lotData.quantity_remaining);
    editPriceInput.value = String(lotData.cost_basis); // Use cost_basis for BUY lots
    editLimitPriceUpInput.value = String(lotData.limit_price_up || '');
    editLimitUpExpirationInput.value = lotData.limit_up_expiration || '';
    editLimitPriceDownInput.value = String(lotData.limit_price_down || '');
    editLimitDownExpirationInput.value = lotData.limit_down_expiration || '';

    // --- Show/Hide sections ---
    if (limitsOnly) {
        modalTitle.textContent = `Set Limits for ${lotData.ticker}`;
        coreFields.style.display = 'none';
        limitFields.style.display = 'block';
    } else {
        modalTitle.textContent = 'Edit Buy Transaction';
        coreFields.style.display = 'block';
        limitFields.style.display = 'none'; // Keep limits hidden when editing core details initially
    }

    // --- Disable fields that shouldn't be changed when editing from dashboard context ---
    editTickerInput.readOnly = true; // Cannot change ticker
    editTypeSelect.disabled = true; // Cannot change type from BUY
    // Consider if quantity/price should be editable if sales exist. For now, allow editing.
    // editQuantityInput.readOnly = (lotData.original_quantity !== lotData.quantity_remaining);
    // editPriceInput.readOnly = (lotData.original_quantity !== lotData.quantity_remaining);

    editModal.classList.add('visible');
}


// --- NEW: Function to populate the Manage Position Modal ---
/**
 * Populates the Manage Position modal with lot details and sales history.
 * @param {string} ticker - The ticker symbol.
 * @param {string} exchange - The exchange name.
 * @param {any[]} buyLots - Array of BUY lot objects for this position.
 * @param {Map<string | number, any[]>} salesByLotId - Map where keys are buyLot IDs and values are arrays of associated sales.
 */
function populateManagementModal(ticker, exchange, buyLots, salesByLotId) {
    const modal = document.getElementById('manage-position-modal');
    const titleEl = document.getElementById('manage-position-title');
    const tickerEl = document.getElementById('manage-position-ticker');
    const exchangeEl = document.getElementById('manage-position-exchange');
    const totalQtyEl = document.getElementById('manage-position-total-qty');
    const avgBasisEl = document.getElementById('manage-position-avg-basis');
    const currentValueEl = document.getElementById('manage-position-current-value');
    const overallPlEl = document.getElementById('manage-position-overall-pl');
    const tbody = document.getElementById('manage-position-tbody');

    if (!modal || !titleEl || !tickerEl || !exchangeEl || !totalQtyEl || !avgBasisEl || !currentValueEl || !overallPlEl || !tbody) {
        console.error("Manage Position Modal: Missing required elements.");
        showToast("UI Error: Cannot display position details.", "error");
        return;
    }

    // --- Calculate Summary ---
    let totalQuantityHeld = 0;
    let totalCostBasisValue = 0;
    let totalCurrentValue = 0;
    const priceData = state.priceCache.get(ticker);
    const currentPrice = (priceData && typeof priceData.price === 'number') ? priceData.price : null;

    buyLots.forEach(lot => {
        totalQuantityHeld += lot.quantity_remaining;
        totalCostBasisValue += lot.cost_basis * lot.quantity_remaining;
        if (currentPrice !== null) {
            totalCurrentValue += currentPrice * lot.quantity_remaining;
        } else {
            totalCurrentValue += lot.cost_basis * lot.quantity_remaining; // Fallback to cost basis
        }
    });

    const weightedAvgCostBasis = totalQuantityHeld > 0 ? totalCostBasisValue / totalQuantityHeld : 0;
    const overallUnrealizedPL = totalCurrentValue - totalCostBasisValue;
    const overallUnrealizedPercent = totalCostBasisValue !== 0 ? (overallUnrealizedPL / totalCostBasisValue) * 100 : 0;
    const plClass = overallUnrealizedPL >= 0 ? 'positive' : 'negative';

    // --- Populate Summary ---
    titleEl.textContent = `Manage Position: ${ticker}`;
    tickerEl.textContent = ticker;
    exchangeEl.textContent = exchange;
    totalQtyEl.textContent = formatQuantity(totalQuantityHeld);
    avgBasisEl.textContent = formatAccounting(weightedAvgCostBasis);
    currentValueEl.textContent = formatAccounting(totalCurrentValue);
    overallPlEl.innerHTML = `<span class="${plClass}">${formatAccounting(overallUnrealizedPL)} (${overallUnrealizedPercent.toFixed(2)}%)</span>`;


    // --- Populate Table ---
    tbody.innerHTML = ''; // Clear previous
    if (buyLots.length === 0) {
        tbody.innerHTML = `<tr><td colspan="8">No open lots found for this position.</td></tr>`;
        return;
    }

    buyLots.forEach(lot => {
        // --- Calculate Unrealized P/L for this lot ---
        let unrealizedPL = 0;
        let unrealizedPercent = 0;
        let unrealizedPLHtml = '--';
        if (currentPrice !== null && lot.quantity_remaining > 0) {
            const costOfRemaining = lot.cost_basis * lot.quantity_remaining;
            unrealizedPL = (currentPrice * lot.quantity_remaining) - costOfRemaining;
            unrealizedPercent = costOfRemaining !== 0 ? (unrealizedPL / costOfRemaining) * 100 : 0;
            const lotPlClass = unrealizedPL >= 0 ? 'positive' : 'negative';
            unrealizedPLHtml = `<span class="${lotPlClass}">${formatAccounting(unrealizedPL)} | ${unrealizedPercent.toFixed(2)}%</span>`;
        }

        // --- Create BUY Row ---
        const buyRow = tbody.insertRow();
        buyRow.classList.add('buy-lot-row'); // Add class for potential styling
        buyRow.dataset.lotId = lot.id;
        buyRow.innerHTML = `
            <td>${lot.purchase_date}</td>
            <td>BUY</td>
            <td class="numeric">${formatAccounting(lot.cost_basis)}</td>
            <td class="numeric">${formatQuantity(lot.original_quantity)}</td>
            <td class="numeric">${formatQuantity(lot.quantity_remaining)}</td>
            <td class="numeric">--</td>
            <td class="numeric">${unrealizedPLHtml}</td>
            <td class="center-align actions-cell">
                <button class="edit-buy-btn" data-id="${lot.id}" title="Edit this Buy Transaction">Edit</button>
                <button class="set-limit-btn" data-id="${lot.id}" title="Set Profit/Loss Limits">Limits</button>
                <button class="sell-from-lot-btn" data-buy-id="${lot.id}" data-ticker="${ticker}" data-exchange="${exchange}" data-quantity="${lot.quantity_remaining}" title="Sell from this Lot">Sell</button>
            </td>
        `;

        // --- Create SELL Rows for this Lot ---
        const sales = salesByLotId.get(lot.id) || [];
        sales.sort((a, b) => a.transaction_date.localeCompare(b.transaction_date)); // Sort sales by date

        sales.forEach(sale => {
            const realizedPLPercent = lot.cost_basis !== 0 ? (sale.realizedPL / (lot.cost_basis * sale.quantity)) * 100 : 0;
            const salePlClass = sale.realizedPL >= 0 ? 'positive' : 'negative';
            const saleRow = tbody.insertRow();
            saleRow.classList.add('sell-row'); // Add class for potential styling
            saleRow.innerHTML = `
                <td>${sale.transaction_date}</td>
                <td>SELL</td>
                <td class="numeric">${formatAccounting(sale.price)}</td>
                <td class="numeric">${formatQuantity(sale.quantity)}</td>
                <td class="numeric">--</td>
                <td class="numeric"><span class="${salePlClass}">${formatAccounting(sale.realizedPL)} | ${realizedPLPercent.toFixed(2)}%</span></td>
                <td class="numeric">--</td>
                <td class="center-align actions-cell"></td>
            `;
        });
    });

    // --- Add Event Listeners (Delegation on tbody) ---
    // Remove previous listeners if any to prevent duplicates
    const oldTbody = document.getElementById('manage-position-tbody');
    const newTbody = oldTbody.cloneNode(true); // Clone to attach new listeners
    oldTbody.parentNode.replaceChild(newTbody, oldTbody);

    newTbody.addEventListener('click', (e) => {
        const target = /** @type {HTMLElement} */ (e.target);
        const editBtn = target.closest('.edit-buy-btn');
        const limitBtn = target.closest('.set-limit-btn');
        const sellBtn = target.closest('.sell-from-lot-btn');
        const sellModal = document.getElementById('sell-from-position-modal');
        const editModal = document.getElementById('edit-modal');


        const lotId = editBtn?.dataset.id || limitBtn?.dataset.id || sellBtn?.dataset.buyId;
        if (!lotId) return;

        // Find the full lot data from state (needed for modals)
        // Note: buyLots passed to populateManagementModal might not have all fields, get from state.dashboardOpenLots
        const lotData = state.dashboardOpenLots.find(lot => String(lot.id) === lotId);
        if (!lotData) {
            showToast('Error: Could not find original lot data in state.', 'error');
            return;
        }

        if (editBtn && editModal) {
            populateEditModal(lotData, false); // False for full edit
        } else if (limitBtn && editModal) {
            populateEditModal(lotData, true); // True for limits only
        } else if (sellBtn && sellModal) {
             const { ticker, exchange, buyId, quantity } = sellBtn.dataset;
             (/** @type {HTMLInputElement} */(document.getElementById('sell-parent-buy-id'))).value = buyId;
             (/** @type {HTMLInputElement} */(document.getElementById('sell-account-holder-id'))).value = String(lotData.account_holder_id);
             document.getElementById('sell-ticker-display').textContent = ticker;
             document.getElementById('sell-exchange-display').textContent = exchange;
             const sellQuantityInput = /** @type {HTMLInputElement} */ (document.getElementById('sell-quantity'));
             sellQuantityInput.value = quantity; // Use remaining quantity
             sellQuantityInput.max = quantity;
             (/** @type {HTMLInputElement} */(document.getElementById('sell-date'))).value = getCurrentESTDateString();
             sellModal.classList.add('visible');
        }
    });


    modal.classList.add('visible'); // Show the modal
}
// --- END NEW FUNCTION ---


/**
 * Loads data for the dashboard page (which triggers the renderer).
 */
export async function loadDashboardPage() {
    await renderDashboardPage();
}

/**
 * Initializes event listeners for Dashboard controls and actions.
 */
export function initializeDashboardHandlers() {
    const dashboardContainer = document.getElementById('dashboard-page-container');
    const filterInput = document.getElementById('dashboard-ticker-filter');
    const sortSelect = document.getElementById('dashboard-sort-select');
    const refreshButton = document.getElementById('dashboard-refresh-prices-btn');
    const subTabsContainer = dashboardContainer?.querySelector('.dashboard-sub-tabs');
    const cardGrid = document.getElementById('positions-cards-grid');
    const positionTable = document.getElementById('open-positions-table');

    // --- Sub-Tab Switching ---
    // ... (Sub-Tab logic remains the same) ...
     if (subTabsContainer && dashboardContainer) {
        subTabsContainer.addEventListener('click', (e) => {
            const target = /** @type {HTMLElement} */ (e.target);
            if (target.classList.contains('sub-tab') && !target.classList.contains('active')) {
                const subTabName = target.dataset.subTab;
                if (!subTabName) return;

                subTabsContainer.querySelectorAll('.sub-tab').forEach(tab => tab.classList.remove('active'));
                dashboardContainer.querySelectorAll('.sub-tab-panel').forEach(panel => panel.classList.remove('active'));

                target.classList.add('active');
                const panelToShow = dashboardContainer.querySelector(`#${subTabName}`);
                if (panelToShow) {
                    panelToShow.classList.add('active');
                }
            }
        });
    }

    // --- Filter and Sort ---
    filterInput?.addEventListener('input', renderDashboardPage);
    sortSelect?.addEventListener('change', renderDashboardPage);

    // --- Refresh Prices ---
    refreshButton?.addEventListener('click', async () => {
        showToast('Refreshing prices...', 'info', 2000);
        await updateAllPrices(); // updateAllPrices now calls renderDashboardPage itself if needed
    });

    // --- Action Buttons (Event Delegation on Card Grid and Table Body) ---
    const handleActionClick = async (e) => {
        const target = /** @type {HTMLElement} */ (e.target);

        // Find the relevant button using closest()
        const sellBtn = target.closest('.sell-from-lot-btn'); // Individual Lot Sell (Single Lot Card or Table Row)
        const selectiveSellBtn = target.closest('.selective-sell-btn'); // Aggregated Card Sell
        const limitBtn = target.closest('.set-limit-btn'); // Single Lot Card or Table Row
        const editBtn = target.closest('.edit-buy-btn'); // Single Lot Card or Table Row
        const historyBtn = target.closest('.sales-history-btn'); // Single Lot Card or Table Row History
        // MODIFIED: Changed selector to manage-position-btn
        const manageLotsBtn = target.closest('.manage-position-btn'); // Aggregated Card Manage Lots/History

        // Modals
        const sellModal = document.getElementById('sell-from-position-modal');
        const selectiveSellModal = document.getElementById('selective-sell-modal');
        const editModal = document.getElementById('edit-modal');
        // MODIFIED: Changed variable name to managePositionModal
        const managePositionModal = document.getElementById('manage-position-modal'); // Get the new modal
        const salesHistoryModal = document.getElementById('sales-history-modal'); // Keep reference if needed elsewhere


        // --- Sell Button Logic (Individual Lot) ---
        // ... (Sell button logic remains the same) ...
        if (sellBtn && sellModal) {
            const { ticker, exchange, buyId, quantity } = sellBtn.dataset;
            // Find lot data - could be from table row (state.dashboardOpenLots) or single lot card (state.dashboardOpenLots)
            const lotData = state.dashboardOpenLots.find(lot => String(lot.id) === buyId);
            if (!lotData) { return showToast('Error: Could not find original lot data.', 'error'); }

            (/** @type {HTMLInputElement} */(document.getElementById('sell-parent-buy-id'))).value = buyId;
            (/** @type {HTMLInputElement} */(document.getElementById('sell-account-holder-id'))).value = String(lotData.account_holder_id);
            document.getElementById('sell-ticker-display').textContent = ticker;
            document.getElementById('sell-exchange-display').textContent = exchange;
            const sellQuantityInput = /** @type {HTMLInputElement} */ (document.getElementById('sell-quantity'));
            sellQuantityInput.value = quantity; // Use remaining quantity
            sellQuantityInput.max = quantity;
            (/** @type {HTMLInputElement} */(document.getElementById('sell-date'))).value = getCurrentESTDateString();

            sellModal.classList.add('visible');
        }
        // --- Selective Sell Button Logic (Aggregated Card) ---
        // ... (Selective sell logic remains the same) ...
        else if (selectiveSellBtn && selectiveSellModal) {
            const { ticker, exchange, totalQuantity, lots: encodedLots } = selectiveSellBtn.dataset;
            if (!ticker || !exchange || !totalQuantity || !encodedLots) {
                showToast('Error: Missing data for selective sell.', 'error');
                return;
            }
             if (state.selectedAccountHolderId === 'all') {
                showToast('Please select a specific account holder before selling.', 'error');
                return;
            }

            let underlyingLots = [];
            try {
                underlyingLots = JSON.parse(decodeURIComponent(encodedLots));
            } catch (err) {
                console.error("Error decoding lots for selective sell:", err);
                showToast('Error: Could not load lot details for selling.', 'error');
                return;
            }

            // --- Populate Modal ---
            document.getElementById('selective-sell-title').textContent = `Sell ${ticker} (${exchange})`;
            (/** @type {HTMLInputElement} */(document.getElementById('selective-sell-ticker'))).value = ticker;
            (/** @type {HTMLInputElement} */(document.getElementById('selective-sell-exchange'))).value = exchange;
            (/** @type {HTMLInputElement} */(document.getElementById('selective-sell-account-holder-id'))).value = String(state.selectedAccountHolderId);
            document.getElementById('selective-sell-available-qty').textContent = formatQuantity(totalQuantity);
            (/** @type {HTMLInputElement} */(document.getElementById('selective-sell-total-quantity'))).value = ''; // Clear previous total
            (/** @type {HTMLInputElement} */(document.getElementById('selective-sell-total-quantity'))).max = totalQuantity; // Set max based on available
            (/** @type {HTMLInputElement} */(document.getElementById('selective-sell-price'))).value = '';
            (/** @type {HTMLInputElement} */(document.getElementById('selective-sell-date'))).value = getCurrentESTDateString();
            document.getElementById('selective-sell-selected-total').textContent = '0'; // Reset selected total
            document.getElementById('selective-sell-validation-message').style.display = 'none'; // Hide validation

            // --- Populate Lots Table ---
            const lotsBody = document.getElementById('selective-sell-lots-body');
            lotsBody.innerHTML = ''; // Clear previous lots
            underlyingLots.forEach(lot => {
                const row = lotsBody.insertRow();
                row.dataset.lotId = lot.id; // Store lot ID
                row.innerHTML = `
                    <td>${lot.purchase_date}</td>
                    <td class="numeric">${formatAccounting(lot.cost_basis)}</td>
                    <td class="numeric">${formatQuantity(lot.quantity_remaining)}</td>
                    <td class="numeric">
                        <input type="number" class="selective-sell-lot-qty"
                               step="any" min="0" max="${lot.quantity_remaining}"
                               data-lot-id="${lot.id}" value="0"
                               style="width: 100px; text-align: right;">
                    </td>
                `;
            });

            // --- Add Input Listeners for Validation ---
            const totalQtyInput = /** @type {HTMLInputElement} */(document.getElementById('selective-sell-total-quantity'));
            const lotQtyInputs = /** @type {HTMLInputElement[]} */(Array.from(lotsBody.querySelectorAll('.selective-sell-lot-qty')));
            const selectedTotalSpan = document.getElementById('selective-sell-selected-total');
            const validationMessage = document.getElementById('selective-sell-validation-message');
            const submitButton = /** @type {HTMLButtonElement} */(document.getElementById('selective-sell-submit-btn'));

            const validateQuantities = () => {
                let selectedTotal = 0;
                lotQtyInputs.forEach(input => {
                    selectedTotal += parseFloat(input.value) || 0;
                });

                const targetTotal = parseFloat(totalQtyInput.value) || 0;
                selectedTotalSpan.textContent = formatQuantity(selectedTotal);

                // Basic validation: Check if total selected matches target total
                const totalsMatch = Math.abs(selectedTotal - targetTotal) < 0.00001 && targetTotal > 0;
                if (totalsMatch) {
                    validationMessage.style.display = 'none';
                    submitButton.disabled = false;
                } else {
                    if (targetTotal > 0) { // Only show message if a target is entered
                        validationMessage.style.display = 'block';
                    } else {
                        validationMessage.style.display = 'none';
                    }
                    submitButton.disabled = true;
                }
            };

            totalQtyInput.addEventListener('input', validateQuantities);
            lotQtyInputs.forEach(input => input.addEventListener('input', validateQuantities));

            validateQuantities(); // Initial validation check
            selectiveSellModal.classList.add('visible');
        }
        // --- Limits Button Logic (Single Lot Card or Table Row) ---
        // ... (Limits button logic remains the same) ...
        else if (limitBtn && editModal) {
            const lotId = limitBtn.dataset.id;
            const lotData = state.dashboardOpenLots.find(lot => String(lot.id) === lotId);
            populateEditModal(lotData, true); // True for limitsOnly
        }
        // --- Edit Button Logic (Single Lot Card or Table Row) ---
        // ... (Edit button logic remains the same) ...
        else if (editBtn && editModal) {
            const lotId = editBtn.dataset.id;
            const lotData = state.dashboardOpenLots.find(lot => String(lot.id) === lotId);
            populateEditModal(lotData, false); // False for full edit
        }
        // --- Sales History Button Logic (Single Lot Card or Table Row) ---
        // ... (Sales History button logic remains the same, using salesHistoryModal) ...
         else if (historyBtn && salesHistoryModal) {
            const buyId = historyBtn.dataset.buyId; // Use data-buy-id
            if (!buyId) return;
            // Find lot data - could be from table row or single lot card
            const lotData = state.dashboardOpenLots.find(lot => String(lot.id) === buyId);
            if (!lotData) { showToast('Could not find original purchase details.', 'error'); return; }
            if (state.selectedAccountHolderId === 'all') { showToast('Please select a specific account holder to view history.', 'error'); return; }

            // Populate static details
            document.getElementById('sales-history-title').textContent = `Sales History for ${lotData.ticker} Lot`; // Specific Lot Title
            document.getElementById('sales-history-ticker').textContent = lotData.ticker;
            document.getElementById('sales-history-buy-date').textContent = lotData.purchase_date;
            document.getElementById('sales-history-buy-qty').textContent = formatQuantity(lotData.original_quantity ?? lotData.quantity);
            document.getElementById('sales-history-buy-price').textContent = formatAccounting(lotData.cost_basis);

            const salesBody = document.getElementById('sales-history-body');
            salesBody.innerHTML = '<tr><td colspan="4">Loading sales history...</td></tr>';
            salesHistoryModal.classList.add('visible'); // Make visible BEFORE fetch

            try {
                // Fetch sales history for this SPECIFIC lot
                const sales = await fetchSalesForLot(buyId, state.selectedAccountHolderId);
                if (sales.length === 0) {
                    salesBody.innerHTML = '<tr><td colspan="4">No sales recorded for this lot.</td></tr>';
                } else {
                    salesBody.innerHTML = sales.map(sale => `
                        <tr>
                            <td>${sale.transaction_date}</td>
                            <td class="numeric">${formatQuantity(sale.quantity)}</td>
                            <td class="numeric">${formatAccounting(sale.price)}</td>
                            <td class="numeric ${sale.realizedPL >= 0 ? 'positive' : 'negative'}">${formatAccounting(sale.realizedPL)}</td>
                        </tr>
                    `).join('');
                }
            } catch (error) {
                showToast(`Error fetching sales history: ${error.message}`, 'error');
                salesBody.innerHTML = '<tr><td colspan="4">Error loading sales history.</td></tr>';
            }
        }
        // --- MODIFIED: Manage Position Button Logic (Aggregated Card) ---
        else if (manageLotsBtn && managePositionModal) { // Target the new modal
            const button = manageLotsBtn;
            const { ticker, exchange, lots: encodedLots } = button.dataset;
            if (!ticker || !exchange || !encodedLots) {
                showToast('Error: Missing data for position management view.', 'error');
                return;
            }
            if (state.selectedAccountHolderId === 'all') {
                showToast('Please select a specific account holder to manage lots.', 'error');
                return;
            }

            let underlyingBuyLots = [];
            try {
                underlyingBuyLots = JSON.parse(decodeURIComponent(encodedLots));
                if (underlyingBuyLots.length === 0) throw new Error("No underlying lot data found.");
                 // Sort lots by purchase date before fetching sales
                 underlyingBuyLots.sort((a, b) => a.purchase_date.localeCompare(b.purchase_date));
            } catch (err) {
                console.error("Error decoding lots for management view:", err);
                showToast('Error: Could not load lot details for management.', 'error');
                return;
            }

            const tbody = document.getElementById('manage-position-tbody');
            if(tbody) tbody.innerHTML = '<tr><td colspan="8">Loading details...</td></tr>'; // Show loading state in table
            managePositionModal.classList.add('visible'); // Show modal early

            try {
                const salesByLotId = new Map();
                const lotIds = underlyingBuyLots.map(lot => lot.id);

                // --- TODO: Replace loop with batch API call ---
                // For now, fetch sales individually
                console.log("Fetching sales individually (Optimize later with batch endpoint)...");
                const salesPromises = lotIds.map(id =>
                    fetchSalesForLot(id, state.selectedAccountHolderId)
                        .then(sales => ({ id, sales }))
                        .catch(err => {
                             console.error(`Error fetching sales for lot ${id}:`, err);
                             return { id, sales: [], error: true }; // Return empty on error for this lot
                        })
                );
                const salesResults = await Promise.all(salesPromises);
                salesResults.forEach(result => {
                    if (!result.error) {
                        salesByLotId.set(result.id, result.sales);
                    } else {
                        salesByLotId.set(result.id, []); // Ensure map has entry even on error
                    }
                });
                // --- End of loop section to replace ---

                // --- Populate the modal using the new function ---
                populateManagementModal(ticker, exchange, underlyingBuyLots, salesByLotId);

            } catch (error) {
                showToast(`Error fetching position details: ${error.message}`, 'error');
                if(tbody) tbody.innerHTML = '<tr><td colspan="8">Error loading details.</td></tr>'; // Show error in table
                // Optionally hide modal: managePositionModal.classList.remove('visible');
            }
        } // --- End of manageLotsBtn logic ---

    }; // End of handleActionClick

    // Attach listener to both potential containers
    cardGrid?.addEventListener('click', handleActionClick);
    positionTable?.querySelector('tbody')?.addEventListener('click', handleActionClick); // Delegate on tbody for actions

    // --- Table Header Sorting ---
    // ... (Table header sorting logic remains the same) ...
     const thead = positionTable?.querySelector('thead');
    if (thead) {
        thead.addEventListener('click', (e) => {
            const target = /** @type {HTMLElement} */ (e.target);
            const th = /** @type {HTMLTableCellElement} */ (target.closest('th[data-sort]'));
            if (th) {
                const tbody = /** @type {HTMLTableSectionElement} */ (document.getElementById('open-positions-tbody'));
                if (tbody) {
                    sortTableByColumn(th, tbody);
                }
            }
        });
    }

    // --- Reconciliation Checkbox Logic (Placeholder) ---
    // ... (Checkbox logic remains the same) ...
    positionTable?.addEventListener('change', (e) => {
        const target = /** @type {HTMLInputElement} */ (e.target);
        if (target.classList.contains('reconciliation-checkbox')) {
            const lotId = target.closest('tr')?.dataset.lotId;
            console.log(`Checkbox for lot ID ${lotId} changed: ${target.checked}`);
            // Add reconciliation tracking logic here if needed
        }
    });

} // End of initializeDashboardHandlers